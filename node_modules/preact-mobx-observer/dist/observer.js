(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('mobx')) :
    typeof define === 'function' && define.amd ? define(['exports', 'mobx'], factory) :
    (global = global || self, factory(global.observer = {}, global.mobx));
}(this, function (exports, mobx) { 'use strict';

    const augment = (object, key, func) => {
        const origMethod = object[key];
        object[key] = function () {
            func.apply(this, arguments);
            if (origMethod) {
                return origMethod.apply(this, arguments);
            }
        };
    };
    const mobxReaction = Symbol("mobxReaction");
    const observer = (comp) => {
        const componentClass = comp;
        augment(componentClass.prototype, "componentWillMount", function () {
            const compName = this.constructor.displayName || this.constructor.name;
            this[mobxReaction] = new mobx.Reaction(`${compName}.render()`, () => this.setState({}));
        });
        augment(componentClass.prototype, "componentWillUnmount", function () {
            this[mobxReaction].dispose();
            this[mobxReaction] = null;
        });
        const origRender = componentClass.prototype.render;
        componentClass.prototype.render = function (props, state, context) {
            let renderResult;
            this[mobxReaction].track(() => {
                renderResult = origRender.call(this, props, state, context);
            });
            return renderResult;
        };
    };

    exports.observer = observer;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=observer.js.map
